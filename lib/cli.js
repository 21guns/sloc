// Generated by CoffeeScript 1.4.0

/*
This program is distributed under the terms of the GPLv3 license.
Copyright 2012 (c) Markus Kohlhase <mail@markus-kohlhase.de>
*/


(function() {
  var BAD_FILE_ERR, BAD_FORMAT_ERR, async, fs, getExtension, parseDir, parseFile, print, programm, sloc, stats;

  fs = require('fs');

  async = require('async');

  sloc = require('./sloc');

  programm = require('commander');

  BAD_FILE_ERR = new Error("bad file");

  BAD_FORMAT_ERR = new Error("bad format");

  getExtension = function(f) {
    var i;
    i = f.lastIndexOf('.');
    if (i < 0) {
      return '';
    } else {
      return f.substr(i).slice(1);
    }
  };

  parseFile = function(f, cb) {
    return fs.readFile(f, "utf8", function(err, code) {
      if (err != null) {
        return typeof cb === "function" ? cb(BAD_FILE_ERR) : void 0;
      } else {
        try {
          return typeof cb === "function" ? cb(null, sloc(code, getExtension(f))) : void 0;
        } catch (e) {
          return typeof cb === "function" ? cb(BAD_FORMAT_ERR) : void 0;
        }
      }
    });
  };

  parseDir = function(dir, cb) {
    var badFileCounter, badFormatCounter, f, files, parseFunctions, _fn, _i, _len;
    badFileCounter = 0;
    badFormatCounter = 0;
    files = (function() {
      var _i, _len, _ref, _results;
      _ref = fs.readdirSync(dir);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        _results.push("" + dir + "/" + f);
      }
      return _results;
    })();
    parseFunctions = [];
    _fn = function(f) {
      return parseFunctions.push(function(next) {
        return parseFile(f, function(err, res) {
          if (err != null) {
            switch (err) {
              case BAD_FORMAT_ERR:
                badFormatCounter++;
                break;
              case BAD_FILE_ERR:
                badFileCounter++;
            }
          }
          return next(null, res);
        });
      });
    };
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      f = files[_i];
      _fn(f);
    }
    return async.parallel(parseFunctions, function(err, res) {
      var r;
      if (err != null) {
        return cb(err);
      } else {
        res = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = res.length; _j < _len1; _j++) {
            r = res[_j];
            if (r != null) {
              _results.push(r);
            }
          }
          return _results;
        })();
        res = res.reduce(function(a, b) {
          var k, o, v;
          o = {};
          for (k in a) {
            v = a[k];
            o[k] = a[k] + b[k];
          }
          return o;
        });
        res.badFiles = badFileCounter;
        res.badFormats = badFormatCounter;
        return cb(null, res);
      }
    });
  };

  print = function(err, r) {
    if (err != null) {
      return console.error(err);
    } else if (programm.json) {
      return console.log(JSON.stringify(r));
    } else if (programm.sloc) {
      return console.log(r.sloc);
    } else {
      console.log("---------- result ------------\n      physical lines :  " + r.loc + "\nlines of source code :  " + r.sloc + "\n       total comment :  " + r.cloc + "\n          singleline :  " + r.scloc + "\n           multiline :  " + r.mcloc + "\n               empty :  " + r.nloc + "\n------------------------------");
      if ((r.badFiles != null) || (r.badFormats != null)) {
        return console.log("unknown source files :  " + r.badFormats + "\n        broken files :  " + r.badFiles + "\n------------------------------");
      }
    }
  };

  programm.version('0.0.2').usage('[option] <file>|<directory>').option('-j, --json', 'return JSON object').option('-s, --sloc', 'print only number of source lines');

  programm.parse(process.argv);

  if (programm.args.length < 1) {
    programm.help();
  } else {
    stats = fs.lstatSync(programm.args[0]);
    if (stats.isDirectory()) {
      parseDir(programm.args[0], print);
    } else if (stats.isFile()) {
      parseFile(programm.args[0], print);
    }
  }

}).call(this);
