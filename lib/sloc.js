// Generated by CoffeeScript 1.7.1

/*
This program is distributed under the terms of the GPLv3 license.
Copyright 2012 - 2014 (c) Markus Kohlhase <mail@markus-kohlhase.de>
 */

(function() {
  var countComments, countMixed, endOfLine, getCommentExpressions, getStop, getType, keys, newLines, nonEmptyLine, slocModule, trampoline;

  keys = ['loc', 'sloc', 'cloc', 'scloc', 'mcloc', 'nloc'];

  nonEmptyLine = /[^\s]/;

  endOfLine = /$/m;

  newLines = /\n/g;

  countMixed = function(lines, match, idx, startIdx, res) {
    if (nonEmptyLine.exec(lines[0]) && idx !== 0) {
      res.push({
        type: 'mixed',
        start: idx,
        stop: idx
      });
    }
    if (nonEmptyLine.exec(lines[startIdx - idx])) {
      return res.push({
        type: 'mixed',
        start: startIdx,
        stop: startIdx
      });
    }
  };

  getStop = function(comment, type, regex) {
    return comment.match((function() {
      switch (type) {
        case 'single':
          return endOfLine;
        case 'block':
          return regex.stop;
      }
    })());
  };

  getType = function(single, start) {
    if (single && !start) {
      return 'single';
    } else if (start && !single) {
      return 'block';
    } else {
      if (start.index <= single.index) {
        return 'block';
      } else {
        return 'single';
      }
    }
  };

  countComments = function(code, regex) {
    var myself;
    myself = function(code, idx, res) {
      var cContentIdx, comment, len, lines, match, single, splitAt, start, startIdx, stop, type, _ref, _ref1, _ref2;
      if (code === '') {
        return res;
      }
      start = (_ref = regex.start) != null ? _ref.exec(code) : void 0;
      single = (_ref1 = regex.single) != null ? _ref1.exec(code) : void 0;
      if (!(start || single)) {
        return res;
      }
      type = getType(single, start);
      match = (function() {
        switch (type) {
          case 'single':
            return single;
          case 'block':
            return start;
        }
      })();
      cContentIdx = match.index + match[0].length;
      comment = code.substring(cContentIdx);
      lines = code.substring(0, match.index).split('\n');
      startIdx = lines.length - 1 + idx;
      stop = getStop(comment, type, regex);
      if (!stop) {
        res.push({
          type: 'error',
          start: idx,
          stop: idx
        });
        return res;
      }
      comment = comment.substring(0, stop.index);
      len = ((_ref2 = comment.match(newLines)) != null ? _ref2.length : void 0) || 0;
      splitAt = cContentIdx + comment.length + stop[0].length;
      code = code.substring(splitAt);
      countMixed(lines, match, idx, startIdx, res);
      res.push({
        type: type,
        start: startIdx,
        stop: startIdx + len
      });
      return function() {
        return myself(code, startIdx + len, res);
      };
    };
    return trampoline(myself(code, 0, []));
  };

  getCommentExpressions = function(lang) {
    var single, start, stop;
    single = (function() {
      switch (lang) {
        case "coffeescript":
        case "coffee":
        case "python":
        case "py":
          return /\#/;
        case "javascript":
        case "js":
        case "c":
        case "cc":
        case "java":
        case "php":
        case "php5":
        case "go":
        case "scss":
        case "less":
        case "styl":
        case "stylus":
          return /\/{2}/;
        case "lua":
          return /--/;
        case "erl":
          return /\%/;
        default:
          return null;
      }
    })();
    switch (lang) {
      case "coffeescript":
      case "coffee":
        start = stop = /\#{3}/;
        break;
      case "javascript":
      case "js":
      case "c":
      case "cc":
      case "java":
      case "php":
      case "php5":
      case "go":
      case "css":
      case "scss":
      case "less":
      case "styl":
      case "stylus":
        start = /\/\*+/;
        stop = /\*\/{1}/;
        break;
      case "python":
      case "py":
        start = stop = /\"{3}|\'{3}/;
        break;
      case "html":
        start = /<\!--/;
        stop = /-->/;
        break;
      case "lua":
        start = /--\[{2}/;
        stop = /--\]{2}/;
        break;
      case "erl":
        start = stop = null;
        break;
      default:
        throw new TypeError("File extension '" + lang + "' is not supported");
    }
    return {
      start: start,
      stop: stop,
      single: single
    };
  };

  trampoline = function(next) {
    while (typeof next === 'function') {
      next = next();
    }
    return next;
  };

  slocModule = function(code, lang) {
    var b, c, cloc, comments, d, i, lineSum, loc, mcloc, mxloc, nloc, res, s, scloc, sloc, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (typeof code !== "string") {
      throw new TypeError("'code' has to be a string");
    }
    loc = 1 + ((_ref = code.match(newLines)) != null ? _ref.length : void 0) || 0;
    nloc = ((_ref1 = code.match(/^\s*$/mg)) != null ? _ref1.length : void 0) || 0;
    comments = countComments(code, getCommentExpressions(lang));
    res = {
      block: [],
      mixed: [],
      single: []
    };
    for (_i = 0, _len = comments.length; _i < _len; _i++) {
      c = comments[_i];
      if ((_ref2 = res[c.type]) != null) {
        _ref2.push(c);
      }
    }
    lineSum = function(comments) {
      var d, i, sum, _j, _len1, _ref3;
      sum = 0;
      for (i = _j = 0, _len1 = comments.length; _j < _len1; i = ++_j) {
        c = comments[i];
        d = (c.stop - c.start) + 1;
        if (((_ref3 = comments[i + 1]) != null ? _ref3.start : void 0) === c.stop) {
          d--;
        }
        sum += d;
      }
      return sum;
    };
    cloc = 0;
    _ref3 = res.block;
    for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
      b = _ref3[i];
      d = (b.stop - b.start) + 1;
      if (((function() {
        var _k, _len2, _ref4, _results;
        _ref4 = res.single;
        _results = [];
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          s = _ref4[_k];
          if (s.start === b.start || s.start === b.stop) {
            _results.push(s);
          }
        }
        return _results;
      })()).length > 0) {
        d -= 3;
      }
      cloc += d;
    }
    scloc = lineSum(res.single);
    cloc += scloc;
    mcloc = lineSum(res.block);
    mxloc = lineSum(res.mixed);
    sloc = loc - scloc - mcloc - nloc + mxloc;
    return {
      loc: loc,
      sloc: sloc,
      cloc: cloc,
      scloc: scloc,
      mcloc: mcloc,
      nloc: nloc
    };
  };

  slocModule.extensions = ["coffeescript", "coffee", "python", "py", "javascript", "js", "c", "cc", "erl", "java", "php", "php5", "go", "lua", "scss", "less", "css", "styl", "stylus", "html"];

  slocModule.keys = keys;

  if ((typeof define !== "undefined" && define !== null ? define.amd : void 0) != null) {
    define(function() {
      return slocModule;
    });
  } else if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = slocModule;
  } else if (typeof window !== "undefined" && window !== null) {
    window.sloc = slocModule;
  }

}).call(this);
